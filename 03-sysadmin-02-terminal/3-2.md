# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

### 1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.
#### Ответ:
Команда `cd` является встроенной в оболочку. В случае если бы команда была бы внешней, вероятно, после осуществления
перехода в другую директорию для работы в ней приходилось бы вызывать новый shel
### 2. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`? `man grep` поможет в ответе на этот вопрос. Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.
#### Ответ:
`grep <some_string> <some_file> -c`
#### Решение:
Команда `grep <some_string> <some_file> | wc -l` ищет строку в файле после чего `wc -l` подсчитывает кол-во найденных строк.
Для этого же действия можно использовать параметр `-с`
### 3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
#### Ответ:
systemd
#### Решение:
```
vagrant@vagrant:~$ pstree 1
pstree 1
systemd─┬─VBoxService───8*[{VBoxService}]
        ├─accounts-daemon───2*[{accounts-daemon}]
        ├─agetty
        ├─atd
        ├─cron
        ├─dbus-daemon
        ├─irqbalance───{irqbalance}
        ├─multipathd───6*[{multipathd}]
        ├─networkd-dispat
        ├─polkitd───2*[{polkitd}]
        ├─rpcbind
        ├─rsyslogd───3*[{rsyslogd}]
        ├─sshd───sshd───sshd───bash───bash───pstree
        ├─systemd───(sd-pam)
        ├─systemd-journal
        ├─systemd-logind
        ├─systemd-network
        ├─systemd-resolve
        └─systemd-udevd
```
### 4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?
#### Ответ:
`ls [dir] 2>/dev/pts/[n]` - где _dir_ - директория, _n_ - номер необходимой сессии. 
### 5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
#### Ответ:
Да возможно.
#### Пример:
`ls -la | grep .. > test.txt`

если без использования PIPE: `cat <test >test.txt`
### 6. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?
#### Ответ:
Да достаточно перенаправить вывод в нужный эмулятор tty

```
vagrant@vagrant:~$ tty
/dev/pts/1
vagrant@vagrant:~$ who
vagrant  tty1         2022-08-08 05:19
vagrant  pts/1        2022-08-08 05:19 (10.0.2.2)
vagrant  pts/2        2022-08-08 05:19 (10.0.2.2)
vagrant@vagrant:~$ echo 123321 >/dev/tty1
vagrant@vagrant:~$
```
### 7. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?
#### Ответ:
Команда создаст дескриптор 5 и перенаправит его в stdout:
```
vagrant@vagrant:~$ ls -la /proc/$$/fd/5
lrwx------ 1 vagrant vagrant 64 Aug 08 05:41 /proc/13710/fd/5 -> /dev/pts/1
```
При выполнении `echo netology > /proc/$$/fd/5`:
```
vagrant@vagrant:~$ echo netology > /proc/$$/fd/5
netology
```
Происходит так по той причине, что дескриптор 5 в который мы выводим _echo_ перенаправлен в stdout
### 8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.
#### Ответ:
ls -la /root 2>&1 1>&5 | grep 'ls' -c
#### Решение:
Используя то что в предыдущем задании мы создали дескриптор с выводом в stdout, можно использовать его, перенаправив в него stdout, предварительно перенаправив stderr в stdout
### 9. Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?
#### Ответ:
Данная команда выводит переменные текущего окружения, аналогичного вывода можно добиться командой `env`
### 10. Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`
#### Ответ:
`/proc/<PID>/cmdline` - отображает полную командную строку запуска процесса, если он полностью не ушел в своп, либо не превратился в зомби, в этом случае отобразит 0 символов

`/proc/<PID>/exe` - Под Linux 2.2 и 2.4 exe является символьной ссылкой содержащей полное имя выполняемого файла.

### 11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`
#### Ответ:
SSE 4.2
#### Решение:
`grep sse /proc/cpuinfo`
### 12. При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:   
```
vagrant@netology1:~$ ssh localhost 'tty'  
not a tty
```
Почитайте, почему так происходит, и как изменить поведение.
#### Ответ:
Предполагаю что так происходит в связи с тем что при подключении к ssh изначально вызывается команда login
и до авторизации не создается псевдо-терминал. Соответственно запрос команды происходит до того как терминал создан.
### 13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.
#### Решение:
`apt-get install reptyr` - устанавливаем `reptyr`

`htop &` - запускаем программу в фон и запоминаем pid

`screen` - создаем скрин

`reptyr 14907` - переназначаем процесс в скрин, и закрываем консоль.

Из другого терминала видим что процесс продолжает работать:
```
vagrant@vagrant:~$ ps aux | grep htop
vagrant    14907  0.0  0.4  10916  4308 pts/2    Ss+  16:48   0:00 htop
vagrant    14918  0.0  0.0      0     0 ?        Z    16:51   0:00 [htop] <defunct>
vagrant    14969  0.0  0.0   8900   736 pts/0    S+   16:52   0:00 grep --color=auto htop
```
### 14. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.
#### Ответ:
Команда `tee` делает вывод из stdin в stdout или в файл. `tee` не является встроенной командой оболочки по этому процесс создастся от sudo в отличии от echo
